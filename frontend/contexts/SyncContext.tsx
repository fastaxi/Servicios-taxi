import React, { createContext, useState, useContext, useEffect, useRef, useCallback } from 'react';
import AsyncStorage from '@react-native-async-storage/async-storage';
import NetInfo from '@react-native-community/netinfo';
import axios from 'axios';
import { useAuth } from './AuthContext';
import { generateClientUUID, isValidClientUUID } from '../utils/uuid';

import { API_URL } from '../config/api';

// --- Types ---

export interface QueuedService {
  client_uuid: string;
  payload: Record<string, any>;
  created_at: string; // ISO 8601
  status: 'pending' | 'syncing' | 'synced' | 'failed';
  error?: string;
}

interface SyncResult {
  client_uuid: string | null;
  server_id: string;
  status: 'created' | 'existing' | 'failed' | 'created_no_uuid';
  error?: string;
}

interface SyncContextType {
  pendingCount: number;
  pendingServices: QueuedService[];
  syncStatus: 'idle' | 'syncing' | 'success' | 'error';
  syncQueue: () => Promise<void>;
  addToQueue: (payload: Record<string, any>, clientUUID: string) => Promise<void>;
}

const SyncContext = createContext<SyncContextType | undefined>(undefined);

// New versioned key to avoid conflicts with old format
const QUEUE_KEY = 'offline_services_queue_v1';
// Old key for migration
const OLD_QUEUE_KEY = 'pendingServices';

export function SyncProvider({ children }: { children: React.ReactNode }) {
  const [queue, setQueue] = useState<QueuedService[]>([]);
  const [syncStatus, setSyncStatus] = useState<'idle' | 'syncing' | 'success' | 'error'>('idle');
  const { token } = useAuth();
  const syncingRef = useRef(false);

  // Load queue (and migrate old format) on mount
  useEffect(() => {
    loadAndMigrateQueue();
  }, []);

  // Auto-sync when network comes back
  useEffect(() => {
    const unsubscribe = NetInfo.addEventListener(state => {
      if (state.isConnected && queue.filter(s => s.status === 'pending' || s.status === 'failed').length > 0) {
        syncQueue();
      }
    });
    return () => unsubscribe();
  }, [queue, token]);

  /**
   * Load queue from AsyncStorage and migrate old-format items
   */
  const loadAndMigrateQueue = async () => {
    try {
      // 1. Load new format
      const raw = await AsyncStorage.getItem(QUEUE_KEY);
      let items: QueuedService[] = raw ? JSON.parse(raw) : [];

      // 2. Migrate old format if present
      const oldRaw = await AsyncStorage.getItem(OLD_QUEUE_KEY);
      if (oldRaw) {
        const oldItems: any[] = JSON.parse(oldRaw);
        if (oldItems.length > 0) {
          const migrated: QueuedService[] = oldItems.map(old => ({
            client_uuid: isValidClientUUID(old.client_uuid) ? old.client_uuid : generateClientUUID(),
            payload: old, // The old item IS the payload
            created_at: new Date().toISOString(),
            status: 'pending' as const,
          }));
          // Remove client_uuid from payload (it lives at top level now)
          migrated.forEach(m => {
            delete m.payload.client_uuid;
          });
          items = [...items, ...migrated];
          // Remove old key
          await AsyncStorage.removeItem(OLD_QUEUE_KEY);
          console.log(`[SyncContext] Migrated ${migrated.length} old queue items`);
        }
      }

      // 3. Ensure all items have valid client_uuid
      let needsPersist = false;
      items = items.map(item => {
        if (!isValidClientUUID(item.client_uuid)) {
          needsPersist = true;
          return { ...item, client_uuid: generateClientUUID() };
        }
        // Reset stuck "syncing" items back to pending
        if (item.status === 'syncing') {
          needsPersist = true;
          return { ...item, status: 'pending' as const };
        }
        return item;
      });

      // Filter out already synced items
      const active = items.filter(i => i.status !== 'synced');
      if (active.length !== items.length) needsPersist = true;

      if (needsPersist || oldRaw) {
        await AsyncStorage.setItem(QUEUE_KEY, JSON.stringify(active));
      }

      setQueue(active);
    } catch (error) {
      console.error('[SyncContext] Error loading queue:', error);
    }
  };

  /**
   * Add a service to the persistent offline queue.
   * The client_uuid must be pre-generated by the caller.
   */
  const addToQueue = useCallback(async (payload: Record<string, any>, clientUUID: string) => {
    try {
      const item: QueuedService = {
        client_uuid: clientUUID,
        payload,
        created_at: new Date().toISOString(),
        status: 'pending',
      };

      const raw = await AsyncStorage.getItem(QUEUE_KEY);
      const items: QueuedService[] = raw ? JSON.parse(raw) : [];

      // Prevent duplicate client_uuid in queue
      if (items.some(existing => existing.client_uuid === clientUUID)) {
        console.log(`[SyncContext] Item with uuid ${clientUUID} already in queue, skipping`);
        return;
      }

      items.push(item);
      await AsyncStorage.setItem(QUEUE_KEY, JSON.stringify(items));
      setQueue(items);

      console.log(`[SyncContext] Queued service ${clientUUID}`);

      // Try immediate sync if connected
      const netInfo = await NetInfo.fetch();
      if (netInfo.isConnected && token) {
        // Small delay to let state settle
        setTimeout(() => syncQueue(), 500);
      }
    } catch (error) {
      console.error('[SyncContext] Error adding to queue:', error);
    }
  }, [token]);

  /**
   * Sync all pending/failed items to the server via POST /api/services/sync
   */
  const syncQueue = useCallback(async () => {
    if (!token || syncingRef.current) return;

    try {
      syncingRef.current = true;
      setSyncStatus('syncing');

      const raw = await AsyncStorage.getItem(QUEUE_KEY);
      if (!raw) {
        setSyncStatus('idle');
        syncingRef.current = false;
        return;
      }

      const items: QueuedService[] = JSON.parse(raw);
      const toSync = items.filter(i => i.status === 'pending' || i.status === 'failed');

      if (toSync.length === 0) {
        setSyncStatus('idle');
        syncingRef.current = false;
        return;
      }

      console.log(`[SyncContext] Syncing ${toSync.length} services...`);

      // Build batch payload: each service includes client_uuid in its payload
      const services = toSync.map(item => ({
        ...item.payload,
        client_uuid: item.client_uuid,
      }));

      const response = await axios.post<{
        message: string;
        results: SyncResult[];
        errors: string[] | null;
      }>(
        `${API_URL}/services/sync`,
        { services },
        { headers: { Authorization: `Bearer ${token}` } }
      );

      const results = response.data.results || [];

      // Map results by client_uuid
      const resultMap = new Map<string, SyncResult>();
      results.forEach(r => {
        if (r.client_uuid) resultMap.set(r.client_uuid, r);
      });

      // Update queue based on results
      const updatedItems = items.map(item => {
        const result = resultMap.get(item.client_uuid);
        if (result) {
          if (result.status === 'created' || result.status === 'existing') {
            return { ...item, status: 'synced' as const };
          } else if (result.status === 'failed') {
            return { ...item, status: 'failed' as const, error: result.error };
          }
        }
        return item;
      });

      // Keep only non-synced items
      const remaining = updatedItems.filter(i => i.status !== 'synced');

      if (remaining.length === 0) {
        await AsyncStorage.removeItem(QUEUE_KEY);
      } else {
        await AsyncStorage.setItem(QUEUE_KEY, JSON.stringify(remaining));
      }

      setQueue(remaining);

      const syncedCount = items.length - remaining.length;
      console.log(`[SyncContext] Synced ${syncedCount}, remaining ${remaining.length}`);

      setSyncStatus(remaining.filter(i => i.status === 'failed').length > 0 ? 'error' : 'success');
      setTimeout(() => setSyncStatus('idle'), 2000);
    } catch (error) {
      console.error('[SyncContext] Sync error:', error);
      setSyncStatus('error');
      setTimeout(() => setSyncStatus('idle'), 3000);
    } finally {
      syncingRef.current = false;
    }
  }, [token]);

  const pendingCount = queue.filter(i => i.status === 'pending' || i.status === 'failed').length;

  return (
    <SyncContext.Provider value={{
      pendingCount,
      pendingServices: queue.filter(i => i.status !== 'synced'),
      syncStatus,
      syncQueue,
      addToQueue,
    }}>
      {children}
    </SyncContext.Provider>
  );
}

export function useSync() {
  const context = useContext(SyncContext);
  if (context === undefined) {
    throw new Error('useSync must be used within a SyncProvider');
  }
  return context;
}
